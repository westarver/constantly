package app

func writeConstants() {
	refreshPreview()
	saveToFile(false) //false that its json
}

func previewString() string {
	var result = "// content generated by constantly\n\npackage " + applicationData.pkg.Text

	if !goType() {
		u := applicationData.userEntries.underlying.Text
		if u == "" {
			u = applicationData.userEntries.underlying.PlaceHolder
		}
		result += "\n\ntype " + applicationData.userEntries.consType.Text + " " + u
	}
	result += "\n\nconst (\n"
	for i := 0; i < applicationData.lastRow; i++ {
		result += makeLineFromTab(i) + "\n"
	}
	result += ")\n"

	if applicationData.userEntries.genStr.Checked {
		result += genStrFuncs()
	}

	if applicationData.userEntries.genAssoc.Checked {
		result += genAssocFuncs()
	}

	if applicationData.userEntries.genValue.Checked {
		result += genValueFuncs()
	}

	if applicationData.userEntries.genMarshal.Checked {
		result += genMarshalFuncs()
	}
	result += "/n// end of content generated by constantly/n"
	return result
}

func refreshPreview() {
	applicationData.preview.SetText(previewString())
}

func makeLineFromTab(row int) string {
	var comment string
	line := "\t"
	value := applicationData.userEntries.cell(Value, row)
	assign := ""

	if len(value) > 0 {
		assign = " = "
	}

	if applicationData.userEntries.genComment.Checked {
		comment += "\t// " + applicationData.userEntries.cell(Assoc, row)
	}

	line += applicationData.userEntries.cell(Prefix, row) + applicationData.userEntries.cell(BaseID, row) + applicationData.userEntries.cell(Suffix, row)
	line += " " + applicationData.userEntries.cell(Type, row) + assign + value

	if len(comment) > 0 {
		line = comment + "\n" + line
	}

	return line
}

func genStrFuncs() string {
	var result string
	if applicationData.userEntries.genStr.Checked {
		result = "\nfunc ConstString(c " + applicationData.userEntries.consType.Text + ") string {\n"
		result += "\tswitch c {\n\t"
		for i := 0; i < applicationData.rows; i++ {
			name := applicationData.userEntries.cell(Prefix, i) + applicationData.userEntries.cell(BaseID, i) + applicationData.userEntries.cell(Suffix, i)
			result += "case " + name + ":\n\t\t"
			result += `return "` + name + "\"\n\t"
		}
		result += "}\n\treturn \"\"\n}\n"
	}
	return result
}

func genAssocFuncs() string {
	var result string
	if applicationData.userEntries.genStr.Checked {
		result = "\nfunc AssocString(c " + applicationData.userEntries.consType.Text + ") string {\n"
		result += "\tswitch c {\n\t"
		for i := 0; i < applicationData.rows; i++ {
			name := applicationData.userEntries.cell(Prefix, i) + applicationData.userEntries.cell(BaseID, i) + applicationData.userEntries.cell(Suffix, i)
			result += "case " + name + ":\n\t\t"
			result += `return "` + applicationData.userEntries.cell(Assoc, i) + "\"\n\t"
		}
		result += "}\n\treturn \"\"\n}\n"
	}
	return result
}

func genValueFuncs() string { return "" }

func genMarshalFuncs() string { return "" }

func goType() bool {
	t := applicationData.userEntries.consType.Text
	// do not use placeholder. if user did not input anything in
	// the type box then assume these are string constants
	switch t {
	case "", "bool", "string",
		"byte", "int8", "uint8",
		"int16", "uint16",
		"int", "uint", "int32", "uint32",
		"int64", "uint64",
		"float32", "float64",
		"complex64", "complex128":
		return true
	}
	return false
}
