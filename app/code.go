package app

func writeConstants() {
	refreshPreview()
	saveToFile(false) //false that its json
}

func previewString() string {
	var result = "// content generated by constantly\n\n"
	if applicationData.pkg.Text != "" {
		result += "package " + applicationData.pkg.Text
	}
	typ := applicationData.userEntries.underlying.Text
	if typ == "" {
		typ = applicationData.userEntries.underlying.PlaceHolder
	}

	result += "\n\ntype " + applicationData.userEntries.consType.Text + " " + typ + "\n"

	if applicationData.userEntries.genStr.Checked {
		result += "\nfunc (c " + applicationData.userEntries.consType.Text + ") String() string {\n\treturn constString(c)\n}\n"
	}
	if applicationData.userEntries.genAssoc.Checked {
		result += "\n\nfunc (c " + applicationData.userEntries.consType.Text + ") Description() string {\n\treturn assocString(c)\n}\n"
	}
	if applicationData.userEntries.genValue.Checked {
		result += "\n\nfunc (c " + applicationData.userEntries.consType.Text + ") Value() " + applicationData.userEntries.consType.Text + " {\n\treturn constValue(c)\n}\n"
	}

	result += "\nconst (\n"
	for i := 0; i < applicationData.lastRow; i++ {
		result += makeLineFromTab(i) + "\n"
	}
	result += ")\n"

	if applicationData.userEntries.genStr.Checked {
		result += genStrFunc()
	}

	if applicationData.userEntries.genAssoc.Checked {
		result += genAssocFunc()
	}

	if applicationData.userEntries.genValue.Checked {
		result += genValueFunc()
	}

	if applicationData.userEntries.genMarshal.Checked {
		result += genMarshalFuncs()
	}
	result += "\n// end of content generated by constantly\n"
	return result
}

func refreshPreview() {
	applicationData.preview.SetText(previewString())
}

func makeLineFromTab(row int) string {
	var comment string
	line := "\t"
	value := applicationData.userEntries.cell(Value, row)
	assign := ""

	if len(value) > 0 {
		assign = " = "
	}

	if applicationData.userEntries.genComment.Checked {
		comment += "\t// " + applicationData.userEntries.cell(Assoc, row)
	}

	line += applicationData.userEntries.cell(Prefix, row) + applicationData.userEntries.cell(BaseID, row) + applicationData.userEntries.cell(Suffix, row)
	line += " " + applicationData.userEntries.cell(Type, row) + assign + value

	if len(comment) > 0 {
		line = comment + "\n" + line
	}

	return line
}

func genStrFunc() string {
	var result string
	if applicationData.userEntries.genStr.Checked {
		result = "\nfunc constString(c " + applicationData.userEntries.consType.Text + ") string {\n"
		result += "\tswitch c {\n\t"
		for i := 0; i < applicationData.lastRow; i++ {
			name := applicationData.userEntries.cell(Prefix, i) + applicationData.userEntries.cell(BaseID, i) + applicationData.userEntries.cell(Suffix, i)
			result += "case " + name + ":\n\t\t"
			result += `return "` + name + "\"\n\t"
		}
		result += "}\n\treturn \"\"\n}\n"
	}
	return result
}

func genAssocFunc() string {
	var result string
	if applicationData.userEntries.genStr.Checked {
		result = "\nfunc assocString(c " + applicationData.userEntries.consType.Text + ") string {\n"
		result += "\tswitch c {\n\t"
		for i := 0; i < applicationData.lastRow; i++ {
			name := applicationData.userEntries.cell(Prefix, i) + applicationData.userEntries.cell(BaseID, i) + applicationData.userEntries.cell(Suffix, i)
			result += "case " + name + ":\n\t\t"
			result += `return "` + applicationData.userEntries.cell(Assoc, i) + "\"\n\t"
		}
		result += "}\n\treturn \"\"\n}\n"
	}
	return result
}

func genValueFunc() string {
	var result string
	if applicationData.userEntries.genValue.Checked {
		result = "\nfunc constValue(c " + applicationData.userEntries.consType.Text + ") " + applicationData.userEntries.consType.Text + " {\n\n"
		result += "\treturn c \n}\n" //+ applicationData.userEntries.cell(Assoc, i) + "\"\n\t"
	}
	return result
}

func genMarshalFuncs() string { return "" }

func goType() bool {
	t := applicationData.userEntries.consType.Text
	// do not use placeholder. if user did not input anything in
	// the type box then assume these are int constants
	switch t {
	case "", "bool", "string",
		"byte", "int8", "uint8",
		"int16", "uint16",
		"int", "uint", "int32", "uint32",
		"int64", "uint64",
		"float32", "float64",
		"complex64", "complex128":
		return true
	}
	return false
}
